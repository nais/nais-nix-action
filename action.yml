name: "Nais Multi App Action"
description: "Build and deploy monorepos from a Nix flake"

inputs:
 project_id:
   description: "Google Cloud project ID"
   required: true
 identity_provider:
   description: "Workload Identity Provider"
   required: true
 team:
   description: "Team name"
   required: true
 registry:
   description: "Docker registry to use"
   default: "europe-north1-docker.pkg.dev"
 push:
   description: "Whether to push images"
   default: true
 debug:
   description: "Enable debug output"
   default: false

outputs:
 apps:
   description: "JSON array of built applications with their details"
   value: ${{ steps.set-outputs.outputs.apps }}

runs:
  using: "composite"
  steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # *** Install nix on the action runner
    - name: Install Nix
      uses: DeterminateSystems/nix-installer-action@v14

    # *** Flake health check
    - name: Check Nix flake inputs
      uses: DeterminateSystems/flake-checker-action@v9

    # *** Magic nix cache
    - uses: DeterminateSystems/magic-nix-cache-action@main

    # *** Flake checks
    - name: Nix Flake Check
      run: nix flake check -L
      shell: bash

    # This is the same as nais/login but without the buildx dependency
    - name: Setup environment
      shell: bash
      id: "setup"
      run: |
        if [ -z "${{ inputs.project_id }}" ]; then
          echo "::error ::project_id not set. Please provide as input."
          exit 1
        elif [ -z "${{ inputs.identity_provider }}" ]; then
          echo "::error ::identity_provider not set. Please provide as input."
          exit 1
        elif [ -z "${{ inputs.team }}" ]; then
          echo "::error ::team not set. Please provide as input."
          exit 1
        fi
        slug=${{ inputs.team }}
        prefix="gar"
        maxLength=30

        hash=$(echo -n "$slug" | sha256sum | cut -d ' ' -f 1)

        prefixLength=${#prefix}
        hashLength=4
        slugLength=$((maxLength - prefixLength - hashLength - 2))

        truncatedSlug=$(echo -n "${slug:0:$slugLength}" | sed 's/-$//')
        truncatedHash=$(echo -n "$hash" | head -c $hashLength)

        # Most of these outputs should probably be envs
        echo "sa_email=${prefix}-${truncatedSlug}-${truncatedHash}@${{ inputs.project_id }}.iam.gserviceaccount.com" >> $GITHUB_OUTPUT
        echo "gar_registry_url=${{ inputs.registry }}/${{ inputs.project_id }}/${{ inputs.team }}" >> $GITHUB_OUTPUT

    - id: "auth"
      name: "Authenticate to Google Cloud"
      uses: "google-github-actions/auth@v2"
      with:
        workload_identity_provider: ${{ inputs.identity_provider }}
        service_account: ${{ steps.setup.outputs.sa_email }}
        token_format: access_token

    - name: "Handle auth failure"
      if: ${{ failure() && steps.auth.outcome == 'failure' }}
      shell: bash
      run: |
        cat <<EOF
        ::error ::Failed to authenticate to Google Cloud.
        EOF

    # *** Login with credentials from Auth
    # Note that this is conditional on inputs.push, which by default is true. you want something else?
    # Try setting it to false
    - name: "Login to registry"
      id: login-to-registry
      if: ${{ inputs.push == 'true' }}
      uses: docker/login-action@343f7c4344506bcbf9b4de18042ae17996df046d # ratchet:docker/login-action@v2
      with:
        registry: "${{ steps.setup.outputs.gar_registry_url }}"
        username: "oauth2accesstoken"
        password: "${{ steps.auth.outputs.access_token }}"


################################ Actual work happens below

    - name: Analyze Flake Apps
      id: analyze
      shell: bash
      run: |
       # Get all apps from the flake
       apps_json=$(nix eval --json .#apps)
       if [[ "${{ inputs.debug }}" == "true" ]]; then
         echo "Raw apps from flake:"
         echo "$apps_json"
       fi

       processed_apps=$(echo "$apps_json" | jq --arg registry "${{ inputs.registry }}" \
                                              --arg project "${{ inputs.project_id }}" \
                                              --arg team "${{ inputs.team }}" \
         'map(. + {
           image_address: "\($registry)/\($project)/\($team)/" + .name,
           has_spec: (.spec != null),
           has_sbom: (.sbom != null)
         })')

       echo "apps=${processed_apps}" >> $GITHUB_OUTPUT
       echo "app_names=$(echo "$processed_apps" | jq -r '.[].name | @json' | tr '\n' ' ')" >> $GITHUB_OUTPUT

    - name: Build Apps
      shell: bash
      run: |
        echo "${{ steps.analyze.outputs.apps }}" | jq -c '.[]' | while read -r app; do
          name=$(echo "$app" | jq -r '.name')
          echo "Building app: $name"

          LOADED_IMAGE=$(nix build ".#apps.${name}.image" --out-link "result-image-${name}" && \
            docker load < "result-image-${name}" | awk -F ': ' '{print $2}')

          IMAGE_ADDRESS=$(echo "$app" | jq -r '.image_address')

          docker tag "$LOADED_IMAGE" "${IMAGE_ADDRESS}:latest"

          if echo "$app" | jq -e '.has_spec'; then
            nix build ".#apps.${name}.spec" --out-link "spec-${name}.yaml"
          fi

          if echo "$app" | jq -e '.has_sbom'; then
            nix build ".#apps.${name}.sbom" --out-link "sbom-${name}.json"
          fi

          echo "âœ… Built $name" >> $GITHUB_STEP_SUMMARY
        done

    - name: Upload Specs
      uses: actions/upload-artifact@v4
      with:
        path: spec-*.yaml
        name: specs

    - name: Push and Upload Artifacts
      id: push-artifacts
      shell: bash
      run: |
        # Initialize an array to collect results
        results=()

        echo "${{ steps.analyze.outputs.apps }}" | jq -c '.[]' | while read -r app; do
          name=$(echo "$app" | jq -r '.name')
          image_address=$(echo "$app" | jq -r '.image_address')

          # Push Docker image if enabled
          if [[ "${{ inputs.push }}" == "true" ]]; then
            echo "Pushing ${image_address}:latest"
            docker push "${image_address}:latest" | tee "push-${name}.txt"
            digest=$(grep "digest:" "push-${name}.txt" | awk '{ print $3 }')
          fi

          # Collect artifacts paths for this app
          artifacts=()
          if [[ -f "spec-${name}.yaml" ]]; then
            artifacts+=("spec-${name}.yaml")
          fi
          if [[ -f "sbom-${name}.json" ]]; then
            artifacts+=("sbom-${name}.json")
          fi

          # Add result for this app
          results+=("{\"name\": \"${name}\", \"image\": \"${image_address}:latest\", \"digest\": \"${digest}\", \"artifacts\": $(printf '%s\n' "${artifacts[@]}" | jq -R . | jq -s .)}")
        done

        # Save final results
        echo "results=[$(IFS=,; echo "${results[*]}")]" >> $GITHUB_OUTPUT
